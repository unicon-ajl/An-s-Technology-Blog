
# 运算符与表达式

> ⚖️ **JavaScript 的“魔法”与“混乱”，常始于一个小小的 `==`**。  
> 理解运算符的优先级、结合性，尤其是**隐式类型转换规则**，是写出可预测代码的关键。

---

## 一、表达式 vs 语句

先明确两个基础概念：

- **表达式（Expression）**：产生一个值  
  ```js
  2 + 3          // → 5
  x > 0 ? "yes" : "no"
  getName()
  ```

- **语句（Statement）**：执行一个动作，不返回值  
  ```js
  if (x > 0) { ... }
  for (let i = 0; i < 10; i++) { ... }
  const y = 5;
  ```

> 💡 表达式可以嵌套在语句中，但语句不能作为值使用（除非用括号包裹成表达式语句）。

---

## 二、常见运算符分类

| 类别 | 运算符 | 示例 |
|------|--------|------|
| **算术** | `+`, `-`, `*`, `/`, `%`, `**` | `5 % 2 → 1`, `2 ** 3 → 8` |
| **比较** | `>`, `<`, `>=`, `<=`, `==`, `!=`, `===`, `!==` | `5 == "5"` → `true` |
| **逻辑** | `&&`, `||`, `!` | `a && b`, `!isValid` |
| **赋值** | `=`, `+=`, `-=`, `??=` | `x += 1` |
| **位运算** | `&`, `|`, `^`, `~`, `<<`, `>>` | 少用，多用于底层操作 |
| **其他** | `? :`（三元）, `typeof`, `instanceof`, `void` | `typeof x`, `arr instanceof Array` |

---

## 三、核心痛点：`==` vs `===`

### `==`（宽松相等）：**会进行隐式类型转换**
```js
5 == "5"        // true  ← 字符串转数字
true == 1       // true  ← 布尔转数字
null == undefined // true ← 特例！
[] == ""        // true  ← 空数组转空字符串
```

### `===`（严格相等）：**不转换类型，直接比较**
```js
5 === "5"       // false
true === 1      // false
null === undefined // false
```

> ✅ **黄金法则：永远使用 `===` 和 `!==`**  
> 除非你**明确需要** `null == undefined` 的宽容行为（如判断“无值”）：
> ```js
> if (value == null) {
>   // value 是 null 或 undefined
> }
> ```

---

## 四、隐式类型转换规则（Coercion）

当运算涉及不同类型时，JS 会自动转换。以下是关键场景：

### 1. 转为布尔值（Truthy / Falsy）
以下值在布尔上下文中为 **falsy**，其余均为 **truthy**：
```js
false, 0, -0, 0n, "", null, undefined, NaN
```

```js
if ("") console.log("不会执行");
if ([], {}) console.log("会执行！对象总是 truthy");
```

> 💡 `!!value` 可显式转布尔：`!!"hello" → true`

---

### 2. 转为字符串
- 使用 `+` 且任一操作数为字符串时：
  ```js
  1 + "2"    // "12"
  [1,2] + "" // "1,2"
  ```

---

### 3. 转为数字
- 使用 `-`, `*`, `/`, `%` 等算术运算符时；
- 比较运算符（除 `===`）也会尝试转数字：
  ```js
  "5" > 3    // true → "5" 转 5
  "a" > 3    // false → "a" 转 NaN，NaN 与任何数比较都为 false
  ```

> ⚠️ 转换顺序复杂，**避免依赖隐式转换**！

---

## 五、逻辑运算符的“短路求值”与妙用

### `&&`（逻辑与）
- 若左侧为 falsy，返回左侧；否则返回右侧。
  ```js
  false && "hello"   // false
  "user" && "admin"  // "admin"
  ```

✅ **安全访问属性**：
```js
const name = user && user.profile && user.profile.name;
// 等价于可选链：user?.profile?.name（ES2020）
```

---

### `||`（逻辑或）
- 若左侧为 truthy，返回左侧；否则返回右侧。
  ```js
  "" || "default"    // "default"
  "Alice" || "Guest" // "Alice"
  ```

✅ **设置默认值**（⚠️ 有局限！）：
```js
function greet(name) {
  name = name || "Guest"; // 若 name 为 falsy（如 0, ""），会被覆盖！
}
```
> ❌ 问题：`0`、`""`、`false` 也是合法输入，却被当作“未提供”。

✅ **改用空值合并运算符 `??`（ES2020）**：
```js
name = name ?? "Guest"; // 仅当 name 为 null 或 undefined 时使用默认值
```

---

## 六、运算符优先级与结合性

### 优先级示例
```js
3 + 4 * 2    // 11（* 优先级高于 +）
true ? 1 : 2 + 3  // 1（?: 优先级低于 +，实际是 true ? 1 : (2+3)）
```

> 🔍 完整优先级表见 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

### 结合性（Associativity）
- 大多数二元运算符**左结合**：`a - b - c` → `(a - b) - c`
- 赋值和三元运算符**右结合**：
  ```js
  a = b = 5; // a = (b = 5)
  cond ? a : cond2 ? b : c; // cond ? a : (cond2 ? b : c)
  ```

> ✅ 不确定时，**加括号**！可读性 > 耀技。

---

## 七、新增运算符（ES2020+）

### 1. 空值合并 `??`
```js
const foo = null ?? "default"; // "default"
const bar = 0 ?? "default";    // 0（因为 0 不是 null/undefined）
```

### 2. 可选链 `?.`
安全访问深层属性：
```js
obj?.prop        // obj.prop（若 obj 为 null/undefined 则返回 undefined）
arr?.[0]         // arr[0]
func?.()         // func()
```

> ✅ 组合使用：
> ```js
> const city = user?.address?.city ?? "未知";
> ```

---

## 最佳实践

✅ **永远用 `===` / `!==`**；  
✅ **用 `??` 替代 `||` 设置默认值**；  
✅ **用 `?.` 避免“Cannot read property of undefined”**；  
✅ **避免依赖隐式转换——显式转换更安全**：
> ```js
> Number("123")   // 字符串 → 数字
> String(42)      // 数字 → 字符串
> Boolean(value)  // 显式转布尔
> ```
✅ **不确定优先级？加括号！**

---

✅ 本篇亮点：
- 直击 `==` 与 `===` 的核心差异，并给出安全使用 `==` 的唯一场景；
- 清晰列出 falsy 值，避免逻辑判断陷阱；
- 对比 `||` 与 `??` 的默认值行为，强调 `0`/`""` 的合法性；
- 引入现代运算符 `?.` 和 `??`，提升代码健壮性；
- 强调“显式转换优于隐式转换”的工程原则。