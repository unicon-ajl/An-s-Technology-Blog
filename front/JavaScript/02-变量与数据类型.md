
# 变量与数据类型

> 🔢 **一切程序，始于对“值”的命名与分类**。  
> JavaScript 的变量声明方式与类型系统，看似简单，却暗藏陷阱——理解它们，是避免 `undefined` 惊喜的第一步。

---

## 一、变量声明：`var`、`let`、`const`

### 1. `var`（历史遗留，慎用 ⚠️）
```js
var name = "Alice";
var name = "Bob"; // 允许重复声明（危险！）
```
- **函数作用域**（不是块级作用域）；
- 存在**变量提升（Hoisting）**：声明被移到作用域顶部，但赋值不会；
- 容易引发意外覆盖和作用域混淆。

> ❌ 不推荐在现代 JS 中使用 `var`。

---

### 2. `let`（可变的块级变量）✅
```js
let age = 25;
age = 26; // ✅ 允许重新赋值
// let age = 30; // ❌ 报错：不能重复声明
```
- **块级作用域**（`{}` 内有效）；
- 不存在变量提升（有“暂时性死区”）；
- 适合用于循环计数器、状态变量等。

---

### 3. `const`（不可变的块级常量）✅ **默认首选**
```js
const PI = 3.14159;
// PI = 3.14; // ❌ 报错：不能重新赋值
```
- 声明时**必须初始化**；
- “不可变”指**绑定不可变**，不等于值不可变（见下文引用类型）；
- 适用于函数、配置、DOM 引用等。

> ✅ **最佳实践：优先用 `const`，仅当需要重新赋值时用 `let`**。

---

## 二、JavaScript 的七种数据类型

JS 有 **7 种数据类型**，分为两类：

### 🟢 原始类型（Primitive Types）— 共 6 种
存储在**栈内存**中，按值访问：

| 类型 | 示例 | 说明 |
|------|------|------|
| `string` | `"hello"` | 字符串 |
| `number` | `42`, `3.14`, `NaN`, `Infinity` | 所有数字都是浮点数 |
| `boolean` | `true`, `false` | 布尔值 |
| `undefined` | `let x;` → `x` 是 `undefined` | 未赋值的变量 |
| `null` | `let user = null;` | “空值”（设计缺陷：`typeof null === "object"`） |
| `symbol` (ES6) | `Symbol('id')` | 唯一标识符，用于对象属性键 |

> 💡 `typeof` 操作符可检测类型：
> ```js
> typeof "abc"     // "string"
> typeof 123       // "number"
> typeof undefined // "undefined"
> typeof null      // "object" ← 历史 bug！
> ```

---

### 🔴 引用类型（Reference Type）— 1 种：`object`
包括：
- 普通对象 `{}`  
- 数组 `[]`  
- 函数 `function() {}`  
- 日期 `new Date()`  
- 正则 `/abc/`  
- 等等

#### 关键特性：**按引用传递**
```js
const user1 = { name: "Alice" };
const user2 = user1; // 复制的是“引用”，不是值
user2.name = "Bob";
console.log(user1.name); // "Bob" ← 原对象也被修改！
```

> ✅ 修改对象属性不会改变引用本身，因此 `const` 对象仍可“内部变化”。

---

## 三、原始类型 vs 引用类型：本质区别

| 特性 | 原始类型 | 引用类型 |
|------|--------|--------|
| 存储位置 | 栈（Stack） | 堆（Heap），变量存指针 |
| 赋值行为 | 复制值 | 复制引用（地址） |
| 比较方式 | 比值 | 比地址（即使内容相同也不相等） |
| 是否可变 | 值不可变 | 内容可变（除非冻结） |

### 示例：比较陷阱
```js
// 原始类型：值相等即相等
5 === 5; // true

// 引用类型：地址不同即不等
[] === []; // false
{} === {}; // false

const a = [];
const b = a;
a === b; // true（同一引用）
```

---

## 四、特殊值详解

### 1. `null` vs `undefined`
|          | `null` | `undefined` |
|----------|--------|-------------|
| 含义     | “有意为空” | “未定义/未初始化” |
| 赋值场景 | 显式设置空值 | 变量声明未赋值、函数无返回值 |
| 类型     | `object`（bug） | `undefined` |

> ✅ 实践建议：**统一用 `null` 表示“空”**，避免混用。

---

### 2. `NaN`（Not-a-Number）
- 表示**无效的数值运算结果**：
  ```js
  "abc" / 2; // NaN
  Math.sqrt(-1); // NaN
  ```
- **唯一不等于自身的值**：
  ```js
  NaN === NaN; // false
  ```
- 检测方法：
  ```js
  isNaN(NaN);        // true（但会强制转换，不安全）
  Number.isNaN(NaN); // true（推荐 ✅）
  ```

---

### 3. `Infinity` 与 `-Infinity`
```js
1 / 0; // Infinity
-1 / 0; // -Infinity
```
- 表示超出 JavaScript 数值范围的正/负无穷大；
- 可参与比较：`Infinity > 999999999999` → `true`

---

## 五、类型转换（Type Coercion）初探

JavaScript 是**动态类型语言**，值可在运行时自动转换类型：

```js
"5" + 3;    // "53"   ← 字符串拼接（+ 触发字符串转换）
"5" - 3;    // 2      ← 数学运算（- 触发数字转换）
!!"hello";  // true   ← 布尔转换
```

> ⚠️ 这是许多 bug 的根源！后续章节将深入讲解转换规则。

---

## 最佳实践

✅ **永远使用 `const` 或 `let`，彻底抛弃 `var`**；  
✅ **用 `const` 声明对象/数组，除非你需要整个替换它**；  
✅ **不要依赖 `typeof null === "object"`**；  
✅ **用 `Number.isNaN()` 检测 NaN**；  
✅ **理解“按值 vs 按引用”是避免数据污染的关键**。

---

✅ 本篇亮点：
- 清晰对比 `var`/`let`/`const` 的作用域与提升行为；
- 用表格和代码示例揭示原始类型与引用类型的本质差异；
- 解释 `null`/`undefined`/`NaN` 的实际使用场景与陷阱；
- 强调“`const` 对象可变内部”的常见困惑点。