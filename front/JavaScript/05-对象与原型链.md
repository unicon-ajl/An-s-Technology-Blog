
# 对象与原型链

> 🔗 **JavaScript 没有“类”，只有对象**。  
> 而“原型链（Prototype Chain）”是它实现继承的唯一机制——理解它，才能看透 `class`、`instanceof` 和方法调用的本质。

---

## 一、对象：键值对的集合

### 1. 创建对象的方式
```js
// 字面量（最常用 ✅）
const user = { name: "Alice", age: 30 };

// 构造函数（不推荐直接使用 Object）
const user2 = new Object({ name: "Bob" });

// Object.create()（用于指定原型）
const user3 = Object.create(null); // 无原型的对象
```

> ✅ **优先使用对象字面量**：简洁、可读、性能好。

---

### 2. 属性访问与动态性
```js
user.name        // "Alice"（点语法）
user["age"]      // 30（方括号，支持变量/特殊字符）

user.email = "alice@example.com"; // 动态添加属性
delete user.age;                  // 删除属性
```

> 💡 JS 对象是**动态的**——可在运行时增删改属性。

---

## 二、this：谁在调用我？

`this` 的值取决于**函数如何被调用**，而非定义位置：

| 调用方式 | `this` 指向 |
|--------|-----------|
| `obj.method()` | `obj` |
| `fn()`（独立调用） | 全局对象（非严格模式）或 `undefined`（严格模式） |
| `new Fn()` | 新创建的实例 |
| `fn.call(obj)` / `fn.apply(obj)` | `obj` |
| 箭头函数 | **继承外层作用域的 `this`**（无自己的 `this`） |

### 示例：this 陷阱
```js
const user = {
  name: "Alice",
  greet() {
    console.log(`Hello, ${this.name}`);
  }
};

user.greet(); // "Hello, Alice" ✅

const fn = user.greet;
fn(); // "Hello, undefined" ❌（this 指向全局）
```

✅ **修复方法**：
- 使用 `.bind()`：`const fn = user.greet.bind(user);`
- 改用箭头函数（若适用）；
- 在对象方法中避免将方法赋值给变量。

---

## 三、原型（Prototype）：对象的“模板”

每个对象都有一个内部属性 `[[Prototype]]`（可通过 `__proto__` 或 `Object.getPrototypeOf()` 访问），指向它的**原型对象**。

### 关键规则：
- 当访问对象属性时，若自身没有，则**沿原型链向上查找**；
- 若找到则返回，否则返回 `undefined`；
- 方法也是属性，同样遵循此规则。

### 示例：手动构建原型链
```js
const animal = {
  speak() {
    return `${this.name} makes a noise.`;
  }
};

const dog = Object.create(animal); // dog 的原型是 animal
dog.name = "Rex";

console.log(dog.speak()); // "Rex makes a noise." ✅
```

> 💡 `Object.create(proto)` 是最清晰的设置原型方式。

---

## 四、构造函数与 prototype 属性

传统“类式”写法（ES5 风格）：

```js
function Person(name) {
  this.name = name;
}

// 所有实例共享的方法放在 prototype 上
Person.prototype.greet = function() {
  return `Hi, I'm ${this.name}`;
};

const alice = new Person("Alice");
console.log(alice.greet()); // "Hi, I'm Alice"
```

### 内部机制：
- `new Person()` 创建新对象；
- 将该对象的 `[[Prototype]]` 指向 `Person.prototype`；
- 执行构造函数，`this` 指向新对象。

> ⚠️ 注意：`Person.prototype` 是**构造函数的属性**，而实例的 `__proto__` 指向它。

---

## 五、class（ES6+）：语法糖，不是新模型

```js
class Person {
  constructor(name) {
    this.name = name;
  }

  greet() {
    return `Hi, I'm ${this.name}`;
  }

  static createAnonymous() {
    return new Person("Anonymous");
  }
}
```

### 实际等价于：
```js
function Person(name) { this.name = name; }
Person.prototype.greet = function() { ... };
Person.createAnonymous = function() { ... }; // static 方法挂构造函数上
```

> ✅ `class` 更清晰、支持私有字段（`#name`）、继承更简洁，但**底层仍是原型链**。

---

## 六、原型链与继承

### 继承示例（ES6 class）
```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(`${this.name} makes a sound.`);
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // 调用父类构造函数
    this.breed = breed;
  }
  bark() {
    console.log("Woof!");
  }
}

const rex = new Dog("Rex", "Husky");
rex.speak(); // "Rex makes a sound."（继承自 Animal）
rex.bark();  // "Woof!"（自身方法）
```

### 原型链结构：
```
rex → Dog.prototype → Animal.prototype → Object.prototype → null
```

> ✅ `instanceof` 判断依据就是原型链：
> ```js
> rex instanceof Dog     // true
> rex instanceof Animal  // true
> rex instanceof Object  // true
> ```

---

## 七、常见误区与陷阱

### 1. 修改内置原型（危险！❌）
```js
Array.prototype.last = function() { return this[this.length - 1]; };
```
- 可能与其他库冲突；
- 破坏 for-in 遍历（除非用 `hasOwnProperty`）；
- **永远不要修改 `Object.prototype`**。

✅ 正确做法：使用工具函数或扩展类。

---

### 2. 原型上的引用类型共享
```js
function User() {}
User.prototype.hobbies = []; // ❌ 所有实例共享同一个数组！

const u1 = new User();
const u2 = new User();
u1.hobbies.push("coding");
console.log(u2.hobbies); // ["coding"] ← 意外共享！
```

✅ 修复：在构造函数中初始化引用类型属性。
```js
function User() {
  this.hobbies = [];
}
```

---

## 最佳实践

✅ **优先使用 `class` 语法（清晰、现代）**；  
✅ **实例属性在 `constructor` 中初始化，方法定义在类体中**；  
✅ **避免直接操作 `__proto__`，用 `Object.create()` 或 `class`**；  
✅ **不要修改内置对象原型**；  
✅ **理解 `this` 绑定规则，必要时用 `.bind()` 或箭头函数**。

---

✅ 本篇亮点：
- 揭示 `class` 本质是原型链的语法糖；
- 用图示和代码清晰展示原型链查找机制；
- 强调 `this` 与调用方式的关系，提供修复方案；
- 指出“原型上放引用类型”的经典陷阱；
- 明确反对修改内置原型，倡导安全扩展。