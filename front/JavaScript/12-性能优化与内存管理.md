
# 性能优化与内存管理

> ⚡ **快，是用户体验的第一道门槛；稳，是长期运行的隐形保障**。  
> JavaScript 虽有自动垃圾回收，但不当使用仍会导致**内存泄漏、卡顿、崩溃**。掌握性能分析与内存管理，是专业开发者的必修课。

---

## 一、性能瓶颈的常见来源

| 类型 | 表现 | 常见原因 |
|------|------|--------|
| **CPU 密集型** | 页面卡顿、动画掉帧 | 复杂计算、深层递归、未优化循环 |
| **内存泄漏** | 内存持续增长、最终崩溃 | 未清理的定时器、闭包引用、DOM 泄漏 |
| **渲染阻塞** | 首屏白屏、交互延迟 | 同步脚本、大体积 JS、未懒加载 |
| **I/O 瓶颈** | 请求慢、数据加载久 | 未缓存、未并行、未压缩 |

> 🔍 优化前先**测量**：用 DevTools 定位真实瓶颈，避免“过早优化”。

---

## 二、关键性能工具（浏览器 DevTools）

### 1. **Performance 面板**
- 记录页面加载或交互过程；
- 分析 **FPS、CPU 使用率、主线程任务**；
- 识别长任务（>50ms）和强制同步布局（Layout Thrashing）。

✅ 使用技巧：
- 点击 **Record** → 操作页面 → 停止；
- 查看 **Main** 轨道中的黄色（Script）、紫色（Render）、绿色（Paint）块。

---

### 2. **Memory 面板**
- 拍摄堆快照（Heap Snapshot）；
- 比较两次快照，找出**新增对象**；
- 检测 **Detached DOM trees**（已从文档移除但仍被 JS 引用的 DOM 节点）。

✅ 典型泄漏线索：
- `Array` / `Map` / `Set` 持续增长；
- 闭包中持有大型对象；
- 事件监听器未移除。

---

### 3. **Lighthouse**
- 自动化审计：性能、可访问性、SEO；
- 给出具体建议（如“移除未使用的 JS”、“启用文本压缩”）。

---

## 三、内存泄漏的四大经典场景

### 1. **未清理的定时器或回调**
```js
function setup() {
  const hugeData = new Array(1e6).fill('*');
  setInterval(() => {
    console.log(hugeData.length); // hugeData 被闭包引用，无法释放
  }, 1000);
}

setup();
// 即使组件卸载，定时器仍在运行！
```

✅ 修复：在销毁时清除
```js
const timer = setInterval(...);
// 组件卸载时
clearInterval(timer);
```

---

### 2. **未移除的事件监听器**
```js
class Modal {
  constructor() {
    this.handleKey = this.onKey.bind(this);
    document.addEventListener('keydown', this.handleKey);
  }

  // ❌ 忘记在关闭时移除
  // destroy() {
  //   document.removeEventListener('keydown', this.handleKey);
  // }
}
```

✅ 修复：实现 `destroy()` 方法并在适当时机调用。

---

### 3. **全局变量或模块缓存无限增长**
```js
// cache.js
const cache = new Map();

export function get(id) {
  if (!cache.has(id)) {
    cache.set(id, fetchData(id)); // 缓存永不清理！
  }
  return cache.get(id);
}
```

✅ 修复：
- 使用 **LRU 缓存**（限制大小）；
- 提供 `clearCache()` 接口；
- 用 `WeakMap` 存储与 DOM/对象生命周期绑定的数据。

---

### 4. **Detached DOM 节点**
```js
const detachedDiv = document.createElement('div');
const button = document.querySelector('#btn');

button.addEventListener('click', () => {
  detachedDiv.innerHTML = 'Clicked'; // 闭包引用 detachedDiv
});
// 若 button 被移除，但监听器未解绑 → detachedDiv 无法 GC
```

✅ 修复：
- 移除元素前解绑事件；
- 避免在闭包中长期持有 DOM 引用。

---

## 四、性能优化策略

### 1. **减少主线程工作**
- **拆分长任务**：用 `setTimeout` 或 `queueMicrotask` 分片；
- **Web Workers**：将 CPU 密集型任务（如加密、图像处理）移出主线程；
  ```js
  const worker = new Worker('worker.js');
  worker.postMessage(data);
  ```

### 2. **高效 DOM 操作**
- **批量更新**：用 `DocumentFragment` 或 `innerHTML` 替代多次 `appendChild`；
- **避免强制同步布局**：
  ```js
  // ❌ 错误：读写交替触发重排
  el.style.height = el.offsetHeight + 10 + 'px';

  // ✅ 正确：先读，后写
  const height = el.offsetHeight;
  el.style.height = height + 10 + 'px';
  ```

### 3. **懒加载与代码分割**
- 路由级懒加载（React/Vue）：
  ```js
  const LazyComponent = React.lazy(() => import('./LazyComponent'));
  ```
- 图片/组件按需加载：
  ```html
  <img loading="lazy" src="image.jpg" />
  ```

### 4. **缓存与复用**
- 函数结果缓存（Memoization）：
  ```js
  const memoize = (fn) => {
    const cache = new Map();
    return (...args) => {
      const key = JSON.stringify(args);
      if (!cache.has(key)) cache.set(key, fn(...args));
      return cache.get(key);
    };
  };
  ```

---

## 五、垃圾回收（GC）机制简述

JavaScript 使用 **标记-清除（Mark-and-Sweep）** 算法：
1. 从根对象（如全局变量、当前执行栈）出发；
2. 标记所有可达对象；
3. 清除未标记对象。

> 💡 **开发者无法控制 GC 时机**，但可通过减少引用帮助引擎回收。

### 弱引用：`WeakMap` / `WeakSet`
- 键必须是对象；
- **不阻止 GC**：当对象仅被 `WeakMap` 引用时，仍可被回收。

```js
const metadata = new WeakMap();

function attachMetadata(obj, data) {
  metadata.set(obj, data);
}

// 当 obj 被 GC，metadata 中的条目自动消失
```

✅ 用途：私有数据存储、DOM 元素关联数据、缓存（避免内存泄漏）。

---

## 六、防抖（Debounce）与节流（Throttle）

### 防抖：高频事件停止后才执行
```js
function debounce(fn, delay) {
  let timeoutId;
  return (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  };
}

window.addEventListener('resize', debounce(handleResize, 300));
```

### 节流：固定间隔最多执行一次
```js
function throttle(fn, limit) {
  let inThrottle;
  return (...args) => {
    if (!inThrottle) {
      fn.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

window.addEventListener('scroll', throttle(trackScroll, 100));
```

> ✅ 用于 `resize`、`scroll`、`input` 等高频事件，减少 CPU 压力。

---

## 最佳实践

✅ **先测量，再优化**——用 Performance/Memory 面板定位问题；  
✅ **及时清理资源**：定时器、事件监听器、订阅；  
✅ **避免全局缓存无限增长**，使用 `WeakMap` 或 LRU 策略；  
✅ **将重计算移至 Web Worker**；  
✅ **用防抖/节流控制高频事件**；  
✅ **理解 GC 原理，但不依赖手动干预**。

---

✅ 本篇亮点：
- 将内存泄漏归纳为四大典型场景，提供可复现代码与修复方案；
- 强调“先测量再优化”的工程思维；
- 介绍 `WeakMap` 在内存安全中的独特价值；
- 提供防抖/节流的生产级实现；
- 关联 Web Workers、代码分割等现代优化手段。