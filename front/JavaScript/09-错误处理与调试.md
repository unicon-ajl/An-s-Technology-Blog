
# 错误处理与调试

> 🛑 **没有程序能永远正确运行，但优秀的程序能优雅地失败**。  
> 掌握错误分类、捕获机制与调试工具，是构建健壮应用的必备能力。

---

## 一、JavaScript 中的错误类型

所有错误都继承自 `Error` 构造函数，常见内置类型：

| 错误类型 | 触发场景 | 示例 |
|---------|--------|------|
| `Error` | 通用错误 | `throw new Error("Something went wrong")` |
| `TypeError` | 类型不匹配 | `"hello".push()` |
| `ReferenceError` | 访问未声明变量 | `console.log(notExist)` |
| `SyntaxError` | 语法错误（无法运行） | `if (true { }` |
| `RangeError` | 数值超出有效范围 | `new Array(-1)` |
| `URIError` | URI 处理函数参数无效 | `decodeURIComponent("%")` |

> 💡 自定义错误应继承 `Error`，便于识别和扩展。

---

## 二、抛出错误：`throw`

```js
// 抛出字符串（不推荐）
throw "Invalid input";

// 抛出 Error 实例（✅ 推荐）
throw new Error("用户名不能为空");

// 自定义错误类
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

throw new ValidationError("邮箱格式错误");
```

> ✅ **始终抛出 `Error` 对象**：包含堆栈信息，便于调试。

---

## 三、捕获错误：`try...catch...finally`

### 基本结构
```js
try {
  // 可能出错的代码
  riskyOperation();
} catch (error) {
  // 处理错误
  console.error("捕获到错误:", error.message);
  logToServer(error); // 上报监控
} finally {
  // 无论是否出错都会执行
  cleanup(); // 如关闭连接、隐藏加载动画
}
```

### 注意：
- **只能捕获同步错误和已 await 的异步错误**；
- **未 await 的 Promise rejection 无法被 try/catch 捕获**！

---

## 四、异步错误处理

### 1. `async/await` + `try/catch`
```js
async function fetchData() {
  try {
    const res = await fetch('/api/data');
    if (!res.ok) throw new Error('请求失败');
    return await res.json();
  } catch (err) {
    console.error('网络错误:', err);
    throw err; // 可选择重新抛出
  }
}
```

### 2. Promise 链中的 `.catch()`
```js
fetchData()
  .then(data => render(data))
  .catch(err => showErrorMessage(err));
```

> ✅ **每个 Promise 链至少有一个 `.catch()`**，避免“未处理 rejection”。

---

## 五、全局错误监听

### 1. 浏览器：`window.onerror`
```js
window.onerror = (message, source, lineno, colno, error) => {
  console.error("全局错误:", error);
  sendErrorToAnalytics(error);
  return true; // 阻止默认错误提示（如控制台红字）
};
```

### 2. Promise 全局拒绝（浏览器 & Node.js）
```js
// 浏览器
window.addEventListener('unhandledrejection', event => {
  console.warn('未处理的 Promise 拒绝:', event.reason);
  event.preventDefault(); // 阻止控制台警告
});

// Node.js
process.on('unhandledRejection', (reason, promise) => {
  console.error('未处理的 rejection:', reason);
});
```

> ⚠️ 全局监听是**兜底方案**，不应替代局部错误处理。

---

## 六、调试技巧与工具

### 1. 控制台日志分级
```js
console.log("普通信息");
console.info("提示信息");
console.warn("警告");
console.error("错误");
console.debug("调试（需开启 verbose 模式）");
```

### 2. 使用断点（Breakpoints）
在浏览器 DevTools 的 **Sources** 面板中：
- 点击行号设置断点；
- 查看调用栈、作用域变量、实时表达式；
- 使用 `debugger` 语句程序化中断：
  ```js
  function problematic() {
    debugger; // 执行到此处自动暂停
    // ...
  }
  ```

### 3. 性能与内存分析
- **Performance 面板**：记录函数执行时间、帧率；
- **Memory 面板**：检测内存泄漏（如未清理的事件监听器）；
- **Network 面板**：查看请求失败、慢加载资源。

---

## 七、生产环境错误监控

开发时靠 `console`，生产环境需专业方案：

### 1. 错误聚合服务
- [Sentry](https://sentry.io/)
- [LogRocket](https://logrocket.com/)
- 自建 ELK（Elasticsearch + Logstash + Kibana）

### 2. 关键信息上报
```js
function reportError(error) {
  fetch('/log-error', {
    method: 'POST',
    body: JSON.stringify({
      message: error.message,
      stack: error.stack,
      url: window.location.href,
      userAgent: navigator.userAgent,
      timestamp: Date.now()
    })
  });
}
```

> ✅ **不要暴露敏感信息**（如用户 token、内部路径）。

---

## 八、防御性编程原则

- **输入验证**：函数开头检查参数类型与范围；
- **默认值兜底**：
  ```js
  function greet(name = "Guest") { ... }
  ```
- **可选链与空值合并**：
  ```js
  const city = user?.address?.city ?? "未知";
  ```
- **Fail Fast**：尽早抛出明确错误，而非返回模糊结果。

---

## 最佳实践

✅ **用 `try/catch` 包裹可能失败的逻辑**；  
✅ **异步操作必须处理 rejection**（`await` + `try/catch` 或 `.catch()`）；  
✅ **自定义错误类提升可读性**；  
✅ **利用 DevTools 断点代替 `console.log` 调试**；  
✅ **生产环境接入错误监控系统**；  
✅ **防御性编程 + 明确错误信息 = 更少线上事故**。

---

✅ 本篇亮点：
- 区分同步与异步错误的捕获边界；
- 强调“未 await 的 Promise 无法被 try/catch 捕获”这一高频陷阱；
- 提供全局错误监听的完整方案（包括 unhandledrejection）；
- 结合 DevTools 实战调试技巧；
- 倡导生产环境错误监控与防御性编程。