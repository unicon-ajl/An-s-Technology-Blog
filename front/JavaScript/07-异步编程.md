
# 异步编程

> ⏳ **JavaScript 是单线程的，却能处理无数并发任务——靠的就是“异步”与“事件循环”**。  
> 从回调地狱到 `async/await`，掌握异步模型，是构建响应式 Web 应用的核心能力。

---

## 一、为什么需要异步？

JavaScript 运行在**单线程**中，若所有操作都同步执行：
```js
// 假设这是同步网络请求（实际会阻塞！）
const data = fetchSync('/api/user'); // 页面卡死直到返回！
```
用户界面将完全冻结，体验极差。

✅ **异步机制**：发起耗时操作（如网络、文件、定时器）后**立即返回**，结果通过**回调**或**Promise**在未来某个时刻处理。

---

## 二、异步演进史：从回调到 async/await

### 1. 回调函数（Callback）— 初期方案，但易陷“地狱”
```js
getUser(1, (user) => {
  getProfile(user.id, (profile) => {
    getPosts(profile.id, (posts) => {
      console.log(posts); // 🤯 嵌套地狱
    });
  });
});
```
- **问题**：嵌套深、错误处理难、控制流混乱。

---

### 2. Promise（ES6）— 链式调用，统一错误处理 ✅
```js
getUser(1)
  .then(user => getProfile(user.id))
  .then(profile => getPosts(profile.id))
  .then(posts => console.log(posts))
  .catch(err => console.error("出错了:", err));
```

#### Promise 的三种状态：
- **pending**（进行中）
- **fulfilled**（成功，调用 `.then()`）
- **rejected**（失败，调用 `.catch()`）

> ✅ **链式调用**：每个 `.then()` 返回新 Promise，可继续链式处理。

---

### 3. async/await（ES2017）— 同步写法，异步执行 ✨
```js
async function loadUserPosts() {
  try {
    const user = await getUser(1);
    const profile = await getProfile(user.id);
    const posts = await getPosts(profile.id);
    console.log(posts);
  } catch (err) {
    console.error("出错了:", err);
  }
}
```

#### 核心规则：
- `async` 函数**总是返回 Promise**；
- `await` 只能在 `async` 函数内使用；
- 错误用 `try...catch` 捕获（像同步代码一样自然）。

> ✅ **现代异步首选方案**：可读性高、调试友好、支持并行优化。

---

## 三、深入事件循环（Event Loop）

JavaScript 如何在单线程中处理异步？靠 **事件循环 + 任务队列**。

### 执行模型：
```
┌──────────────┐
│   Call Stack │ ← 同步代码逐行执行
└──────┬───────┘
       │
       ▼
┌──────────────┐     ┌──────────────┐
│  Callback    │◄───►│  Event Loop  │
│   Queue      │     └──────────────┘
└──────────────┘
```

### 两类任务：
| 类型 | 示例 | 特点 |
|------|------|------|
| **宏任务（Macrotask）** | `setTimeout`, `setInterval`, I/O, UI 渲染 | 每次事件循环只执行一个 |
| **微任务（Microtask）** | `Promise.then`, `queueMicrotask`, `MutationObserver` | 一次宏任务后，**清空所有微任务队列** |

### 示例：执行顺序
```js
console.log("1");

setTimeout(() => console.log("2"), 0);

Promise.resolve().then(() => console.log("3"));

console.log("4");
```

**输出**：`1 → 4 → 3 → 2`

> 💡 微任务优先级高于宏任务！

---

## 四、并发控制：并行 vs 串行

### 1. 并行执行（推荐，更快）
```js
async function loadAll() {
  const [user, settings] = await Promise.all([
    fetchUser(),
    fetchSettings()
  ]);
}
```
- `Promise.all()`：所有 Promise 同时发起，任一失败则整体失败；
- `Promise.allSettled()`：等待所有完成（无论成败）；
- `Promise.race()`：返回第一个完成的 Promise。

---

### 2. 串行执行（依赖前一步结果）
```js
const user = await fetchUser();
const posts = await fetchPosts(user.id); // 必须等 user
```

> ✅ 能并行就并行，减少总耗时。

---

## 五、常见陷阱与最佳实践

### 1. 忘记 `await` 或 `.catch()`
```js
// ❌ 危险：未处理的 rejected Promise
someAsyncFn();

// ✅ 正确
await someAsyncFn(); // 在 async 函数中
// 或
someAsyncFn().catch(console.error);
```

> 🔥 未处理的 Promise rejection 会导致静默失败！

---

### 2. 在循环中错误使用 `await`
```js
// ❌ 串行执行（慢！）
for (const id of ids) {
  const data = await fetch(`/api/${id}`); // 一个接一个
}

// ✅ 并行执行（快！）
const promises = ids.map(id => fetch(`/api/${id}`));
const results = await Promise.all(promises);
```

---

### 3. 混淆 `async` 函数的返回值
```js
async function getValue() {
  return 42;
}

getValue().then(x => console.log(x)); // 42（不是 Promise！）
```
- `async` 函数返回的是 **resolved 的 Promise**，值被自动包装。

---

## 六、现代异步工具补充

### 1. `AbortController` — 取消请求
```js
const controller = new AbortController();
fetch('/api/data', { signal: controller.signal });

// 取消
controller.abort();
```

### 2. Top-level `await`（ES2022，模块中可用）
```js
// 在 .mjs 或 <script type="module"> 中
const config = await loadConfig();
```

---

## 最佳实践

✅ **优先使用 `async/await`**，逻辑清晰、错误处理直观；  
✅ **用 `Promise.all` 实现并行请求**，提升性能；  
✅ **始终处理 Promise rejection**（`try/catch` 或 `.catch()`）；  
✅ **理解事件循环，避免阻塞主线程**；  
✅ **用 `AbortController` 支持取消操作，提升用户体验**。

---

✅ 本篇亮点：
- 用“1 → 4 → 3 → 2”示例清晰揭示微任务/宏任务执行顺序；
- 对比回调、Promise、async/await 的演进逻辑；
- 强调 `Promise.all` 并行 vs 循环 `await` 串行的性能差异；
- 指出未处理 rejection 的静默失败风险；
- 引入 `AbortController` 等现代取消机制。