
# 数组与常用方法

> 🧩 **数组是 JavaScript 中最常用的数据结构**。  
> 而 `map`、`filter`、`reduce` 等高阶方法，不仅是函数式编程的基石，更是写出**简洁、可读、无副作用**代码的关键。

---

## 一、数组的本质：特殊的对象

在 JavaScript 中，**数组是对象的子类型**：
```js
typeof []; // "object"
Array.isArray([]); // true ✅（正确检测方式）
```

### 特性：
- **索引是字符串**（`arr[0]` 实际是 `arr["0"]`）；
- 拥有 `length` 属性，会自动更新；
- 继承自 `Array.prototype`，拥有大量内置方法。

> ⚠️ 不要用 `for...in` 遍历数组——它会遍历所有可枚举属性（包括非数字键）！

---

## 二、创建数组

```js
// 字面量（推荐 ✅）
const fruits = ["apple", "banana"];

// 构造函数（谨慎使用）
const arr1 = new Array(3);     // [empty × 3]（稀疏数组！）
const arr2 = new Array(1, 2);  // [1, 2]

// 静态方法
const zeros = Array(5).fill(0);        // [0, 0, 0, 0, 0]
const fromStr = Array.from("abc");     // ["a", "b", "c"]
const range = Array.from({ length: 5 }, (_, i) => i); // [0, 1, 2, 3, 4]
```

> ✅ 优先使用字面量或 `Array.from()`，避免 `new Array(n)` 的陷阱。

---

## 三、核心高阶方法：函数式三剑客

### 1. `map()` —— **转换**
对每个元素应用函数，返回**新数组**（长度不变）。

```js
const numbers = [1, 2, 3];
const doubled = numbers.map(x => x * 2); // [2, 4, 6]
```

✅ 用途：格式化数据、提取属性、计算派生值。

---

### 2. `filter()` —— **筛选**
保留回调返回 `true` 的元素，返回**新数组**（长度 ≤ 原数组）。

```js
const users = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 17 }
];

const adults = users.filter(u => u.age >= 18);
// [{ name: "Alice", age: 25 }]
```

✅ 用途：条件过滤、权限控制、数据清洗。

---

### 3. `reduce()` —— **聚合**
将数组“归约”为单个值（如求和、分组、扁平化）。

```js
// 求和
const sum = [1, 2, 3].reduce((acc, val) => acc + val, 0); // 6

// 分组
const byAge = users.reduce((groups, user) => {
  const key = user.age >= 18 ? "adult" : "minor";
  (groups[key] = groups[key] || []).push(user);
  return groups;
}, {});
```

✅ 参数：`(accumulator, currentValue, index, array) => newValue`  
✅ 初始值（如 `0`, `{}`, `[]`）通常必须提供。

---

## 四、其他实用方法

| 方法 | 作用 | 示例 |
|------|------|------|
| `find()` | 返回第一个满足条件的元素 | `arr.find(x => x > 10)` |
| `some()` / `every()` | 是否有/全部满足条件 | `[2,4].every(x => x % 2 === 0)` → `true` |
| `includes()` | 是否包含某值（替代 `indexOf !== -1`） | `[1,2].includes(2)` → `true` |
| `flat()` / `flatMap()` | 扁平化嵌套数组 | `[[1], [2]].flat()` → `[1, 2]` |
| `at()`（ES2022） | 支持负索引 | `arr.at(-1)` → 最后一个元素 |

---

## 五、解构赋值：优雅提取数组元素

```js
const [first, second] = ["a", "b", "c"];
console.log(first);  // "a"
console.log(second); // "b"

// 跳过元素
const [,, third] = ["a", "b", "c"]; // third = "c"

// 默认值
const [x = 0, y = 0] = [5]; // x=5, y=0

// 剩余参数
const [head, ...tail] = [1, 2, 3, 4]; // head=1, tail=[2,3,4]
```

✅ 用途：函数参数处理、交换变量、API 响应解析。

---

## 六、迭代协议与 for...of

ES6 引入**可迭代协议（Iterable Protocol）**，使数组支持 `for...of`：

```js
for (const item of fruits) {
  console.log(item);
}
```

### 优势 vs `for...in` 和传统 `for`：
- `for...of`：遍历**值**，安全、简洁；
- `for...in`：遍历**键（字符串）**，不适用于数组；
- 传统 `for`：需手动管理索引，易出错。

> ✅ **优先使用 `for...of` 或高阶方法，而非传统 `for` 循环**。

---

## 七、常见陷阱

### 1. 方法是否修改原数组？
| 修改原数组（Mutating） | 返回新数组（Non-mutating） |
|----------------------|--------------------------|
| `push`, `pop`, `shift`, `unshift` | `map`, `filter`, `slice` |
| `splice`, `sort`, `reverse` | `concat`, `flat`, `flatMap` |

> ❌ 错误示例：
> ```js
> const sorted = arr.sort(); // arr 也被排序了！
> ```
> ✅ 安全做法：
> ```js
> const sorted = [...arr].sort(); // 先浅拷贝
> ```

---

### 2. 稀疏数组（Sparse Arrays）
```js
const arr = new Array(3); // [empty × 3]
arr.map(x => x * 2);      // [empty × 3] ← map 跳过空位！
```
- 空位 ≠ `undefined`；
- 大多数方法会跳过空位，行为不可预测。

✅ 避免创建稀疏数组，用 `Array(n).fill().map(...)` 代替。

---

## 最佳实践

✅ **优先使用 `map`/`filter`/`reduce` 替代 `for` 循环**；  
✅ **链式调用提升可读性**：`data.filter(...).map(...).reduce(...)`；  
✅ **用解构简化变量提取**；  
✅ **用 `for...of` 遍历值，避免 `for...in`**；  
✅ **警惕 mutating 方法，保持数据不可变（Immutable）**；  
✅ **用 `Array.isArray()` 检测数组，而非 `typeof`**。

---

✅ 本篇亮点：
- 明确区分 mutating 与 non-mutating 方法，强调不可变性；
- 用表格对比函数式三剑客的核心用途；
- 揭示稀疏数组的隐藏陷阱；
- 推荐 `for...of` + 高阶方法作为现代遍历标准；
- 提供链式调用和解构的实际价值。