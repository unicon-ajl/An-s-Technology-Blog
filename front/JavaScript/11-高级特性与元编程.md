
# 高级特性与元编程

> 🪞 **元编程（Metaprogramming）：让程序能读写、修改甚至生成自身结构**。  
> JavaScript 提供了 `Proxy`、`Reflect`、`Symbol` 等强大工具，使运行时自省与行为拦截成为可能。

---

## 一、什么是元编程？

**元编程 = 编写操作“程序本身”的程序**。  
在 JS 中，这意味着：
- 拦截对象属性访问；
- 自定义函数调用行为；
- 动态定义类或方法；
- 实现响应式系统、ORM、验证框架等底层机制。

> 💡 元编程不是日常业务代码的主角，但它是**框架和库的核心引擎**（如 Vue 3 的响应式、MobX、Jest mock）。

---

## 二、Symbol：唯一且不可枚举的键

### 1. 创建唯一标识符
```js
const id = Symbol('user-id');
const obj = {
  [id]: 123,
  name: "Alice"
};

console.log(obj[id]); // 123
console.log(Object.keys(obj)); // ["name"] ← Symbol 键不被枚举
```

### 2. 内置 Symbol（Well-known Symbols）
用于自定义语言行为：

| Symbol | 用途 |
|--------|------|
| `Symbol.iterator` | 定义对象的默认迭代器 |
| `Symbol.toPrimitive` | 自定义类型转换为原始值 |
| `Symbol.hasInstance` | 自定义 `instanceof` 行为 |
| `Symbol.toStringTag` | 自定义 `Object.prototype.toString` 输出 |

#### 示例：自定义迭代器
```js
const range = {
  from: 1,
  to: 5,
  [Symbol.iterator]() {
    return {
      current: this.from,
      last: this.to,
      next() {
        if (this.current <= this.last) {
          return { value: this.current++, done: false };
        }
        return { done: true };
      }
    };
  }
};

for (const num of range) {
  console.log(num); // 1, 2, 3, 4, 5
}
```

> ✅ `Symbol.iterator` 是 `for...of`、扩展运算符 `...`、解构等语法的基础。

---

## 三、Proxy：拦截并自定义对象操作

`Proxy` 允许你**拦截对目标对象的各种操作**，并定义自定义行为。

### 基本语法
```js
const target = {};
const handler = {
  get(obj, prop) {
    return prop in obj ? obj[prop] : '默认值';
  },
  set(obj, prop, value) {
    if (typeof value === 'string') {
      obj[prop] = value.trim();
      return true; // 必须返回 true 表示成功
    }
    throw new Error('只接受字符串');
  }
};

const proxy = new Proxy(target, handler);
proxy.name = " Alice "; // 自动 trim → "Alice"
console.log(proxy.name); // "Alice"
console.log(proxy.age);  // "默认值"
```

### 常用陷阱（Traps）
| 拦截操作 | handler 方法 |
|--------|-------------|
| 读取属性 | `get(target, prop, receiver)` |
| 设置属性 | `set(target, prop, value, receiver)` |
| 检查 in | `has(target, prop)` |
| 删除属性 | `deleteProperty(target, prop)` |
| 枚举 keys | `ownKeys(target)` |
| `Object.keys()` | `getOwnPropertyDescriptor` + `ownKeys` |
| 函数调用 | `apply(target, thisArg, args)` |

---

## 四、Reflect：标准化的对象操作 API

`Reflect` 提供与 `Proxy` traps 对应的静态方法，语义更清晰：

| 旧写法 | 新写法（推荐） |
|-------|---------------|
| `obj[prop]` | `Reflect.get(obj, prop)` |
| `obj[prop] = val` | `Reflect.set(obj, prop, val)` |
| `delete obj[prop]` | `Reflect.deleteProperty(obj, prop)` |
| `prop in obj` | `Reflect.has(obj, prop)` |

### 优势：
- **函数式风格**：可作为参数传递；
- **统一返回值**：如 `Reflect.set()` 返回 `true/false`，而直接赋值无反馈；
- **与 Proxy 完美配合**。

#### Proxy + Reflect 组合示例
```js
function createLoggedObject(obj) {
  return new Proxy(obj, {
    get(target, prop, receiver) {
      console.log(`读取 ${String(prop)}`);
      return Reflect.get(target, prop, receiver);
    },
    set(target, prop, value, receiver) {
      console.log(`设置 ${String(prop)} = ${value}`);
      return Reflect.set(target, prop, value, receiver);
    }
  });
}

const user = createLoggedObject({ name: "Alice" });
user.name = "Bob"; // 日志：设置 name = Bob
```

> ✅ 这是实现**响应式系统**（如 Vue 3）的基础。

---

## 五、动态代码执行：`eval()` 与 `Function`

### 1. `eval(str)` —— **危险！避免使用**
```js
eval("console.log('Hello')"); // 执行任意代码
```
- 破坏作用域链；
- 安全风险（XSS）；
- 阻碍优化。

### 2. `new Function(...args, body)` —— 相对安全
```js
const add = new Function('a', 'b', 'return a + b;');
console.log(add(2, 3)); // 5
```
- 在**全局作用域**中执行，不访问外层变量；
- 可用于模板引擎、规则引擎等受控场景。

> ⚠️ 仍需谨慎：仅在完全信任输入时使用。

---

## 六、装饰器（Decorators，Stage 3 提案）

虽然尚未正式纳入标准，但已被 TypeScript 和 Babel 广泛支持，用于**注解类、方法、属性**。

### 示例（TypeScript 风格）
```ts
function readonly(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  descriptor.writable = false;
}

class Config {
  @readonly
  version = "1.0";
}

const c = new Config();
c.version = "2.0"; // ❌ TypeError（严格模式下）
```

> 🔜 装饰器将成为元编程的重要语法糖，用于 AOP（面向切面编程）、依赖注入等。

---

## 七、实际应用场景

### 1. 响应式数据（Vue 3 核心）
```js
function reactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      track(target, key); // 依赖收集
      return Reflect.get(target, key);
    },
    set(target, key, value) {
      const result = Reflect.set(target, key, value);
      trigger(target, key); // 触发更新
      return result;
    }
  });
}
```

### 2. 数据验证
```js
function withValidation(schema) {
  return (target) => new Proxy(target, {
    set(obj, prop, value) {
      if (schema[prop] && !schema[prop](value)) {
        throw new Error(`Invalid value for ${prop}`);
      }
      return Reflect.set(obj, prop, value);
    }
  });
}

const user = withValidation({
  age: v => typeof v === 'number' && v > 0
})({});
user.age = -5; // ❌ 抛出错误
```

### 3. Mock 与测试
```js
const mockFetch = new Proxy(fetch, {
  apply(target, thisArg, args) {
    if (args[0] === '/api/user') {
      return Promise.resolve({ json: () => ({ id: 1 }) });
    }
    return target.apply(thisArg, args);
  }
});
```

---

## 最佳实践

✅ **用 `Symbol` 定义非冲突的内部属性或方法**；  
✅ **用 `Proxy` + `Reflect` 实现拦截逻辑（如日志、验证、响应式）**；  
✅ **避免 `eval()`，必要时用 `new Function()`**；  
✅ **理解 `Symbol.iterator` 是可迭代协议的核心**；  
✅ **大型项目可借助装饰器（TypeScript/Babel）提升元编程能力**；  
✅ **元编程用于框架/工具层，业务代码保持简洁**。

---

✅ 本篇亮点：
- 将 `Proxy`/`Reflect` 与实际框架（如 Vue 3）联系起来，揭示其工业价值；
- 清晰解释 `Symbol` 在迭代、类型转换等场景的作用；
- 提供响应式、验证、Mock 等真实元编程案例；
- 警示 `eval` 风险，引导安全替代方案；
- 强调元编程应“藏于底层，显于接口”。