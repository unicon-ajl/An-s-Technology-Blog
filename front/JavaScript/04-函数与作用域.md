
# 函数与作用域

> 🧠 **函数是 JavaScript 的“第一公民”**——它不仅是代码组织单元，更是作用域、闭包、回调、高阶编程的基石。  
> 而“作用域”，决定了变量在哪里可见、何时回收。理解它们，就掌握了 JS 的灵魂。

---

## 一、函数的多种声明方式

### 1. 函数声明（Function Declaration）
```js
function greet(name) {
  return `Hello, ${name}!`;
}
```
- **会被提升（Hoisted）**：可在声明前调用；
- 具名，便于调试和递归。

✅ 推荐用于大多数场景。

---

### 2. 函数表达式（Function Expression）
```js
const greet = function(name) {
  return `Hello, ${name}!`;
};
```
- **不会被提升**（受 `const`/`let` 规则约束）；
- 可匿名，也可具名（用于递归或栈追踪）：
  ```js
  const factorial = function f(n) {
    return n <= 1 ? 1 : n * f(n - 1);
  };
  ```

---

### 3. 箭头函数（Arrow Function，ES6）✅ **现代首选**
```js
const greet = (name) => `Hello, ${name}!`;

// 多参数、多语句
const add = (a, b) => {
  console.log("Adding...");
  return a + b;
};
```

#### 箭头函数的三大特性：
1. **更简洁语法**（省略 `function`、`return`、括号）；
2. **没有自己的 `this`** → 继承外层作用域的 `this`（解决回调中 `this` 丢失问题）；
3. **不能作为构造函数**（无 `prototype`，不能用 `new`）。

> ✅ 适合：回调、工具函数、纯计算逻辑。  
> ❌ 不适合：需要动态 `this` 的方法（如事件处理器、对象方法）。

---

## 二、作用域（Scope）：变量的“可见范围”

### 1. 全局作用域（Global Scope）
- 在任何函数/块外定义的变量；
- 浏览器中挂载到 `window`，Node.js 中为模块级。

```js
var globalVar = "I'm global"; // 挂到 window
let alsoGlobal = "Me too";    // 不挂 window，但仍是全局
```

> ⚠️ 避免污染全局作用域！

---

### 2. 函数作用域（Function Scope）
- `var` 声明的变量在**函数内**有效；
- 内部函数可访问外部变量（**词法作用域**）。

```js
function outer() {
  var x = 1;
  function inner() {
    console.log(x); // ✅ 可访问外层 x
  }
}
```

---

### 3. 块级作用域（Block Scope，ES6+）
- `let` / `const` 在 `{}` 内创建新作用域；
- `if`、`for`、`while` 等语句块也形成作用域。

```js
if (true) {
  let blockVar = "inside";
}
console.log(blockVar); // ❌ ReferenceError
```

> ✅ 块级作用域让变量生命周期更可控，减少意外覆盖。

---

## 三、闭包（Closure）：函数的“记忆能力”

> **闭包 = 函数 + 其词法环境（Lexical Environment）**

当一个内部函数**引用了外部函数的变量**，即使外部函数已执行完毕，这些变量仍被“记住”。

### 经典示例：计数器
```js
function createCounter() {
  let count = 0; // 外部变量
  return function() {
    count++;       // 内部函数引用它
    return count;
  };
}

const counter = createCounter();
counter(); // 1
counter(); // 2 ← count 未被销毁！
```

### 闭包的用途
- **数据私有化**（模拟私有变量）；
- **回调函数携带上下文**（如事件监听、定时器）；
- **函数工厂**（生成定制化函数）。

> 💡 闭包不是 bug，而是 JS 的核心设计特性。

---

## 四、变量提升（Hoisting）详解

JS 引擎在执行前会先“扫描”代码，将**声明**提升到作用域顶部：

### `var` 提升（仅声明，不赋值）
```js
console.log(x); // undefined（不是报错！）
var x = 5;
// 实际执行顺序：
// var x;
// console.log(x);
// x = 5;
```

### `let` / `const`：存在“暂时性死区”（TDZ）
```js
console.log(y); // ❌ ReferenceError
let y = 10;
```
- 在声明前访问会报错；
- 防止意外使用未初始化变量。

> ✅ TDZ 是 `let`/`const` 比 `var` 更安全的关键原因。

---

## 五、this 的绑定规则（简要预览）

`this` 的值**不由定义位置决定，而由调用方式决定**：

| 调用方式 | `this` 指向 |
|--------|-----------|
| `obj.method()` | `obj` |
| `fn()`（独立调用） | 全局对象（浏览器=`window`，严格模式=`undefined`） |
| `new Fn()` | 新创建的实例 |
| `fn.call(obj)` | `obj` |

> 🔜 详细讲解见后续《对象与原型链》篇。  
> 💡 箭头函数**没有自己的 `this`**，始终继承外层。

---

## 六、高阶函数（Higher-Order Functions）

**接收函数作为参数，或返回函数的函数**。

### 示例：通用日志包装器
```js
function withLogging(fn) {
  return function(...args) {
    console.log("Calling", fn.name, "with", args);
    return fn(...args);
  };
}

const safeAdd = withLogging((a, b) => a + b);
safeAdd(2, 3); // Logs: Calling (anonymous) with [2, 3]
```

> ✅ 高阶函数是函数式编程的基础，广泛用于 React、Redux 等库。

---

## 最佳实践

✅ **优先使用箭头函数处理回调和纯函数**；  
✅ **用 `const`/`let` + 块级作用域替代 `var`**；  
✅ **利用闭包实现数据封装，但避免无意识内存泄漏**；  
✅ **不要依赖变量提升——先声明，再使用**；  
✅ **理解 `this` 绑定规则，必要时用 `.bind()` 或箭头函数修正**。

---

✅ 本篇亮点：
- 清晰对比三种函数声明方式及适用场景；
- 用“计数器”示例直观解释闭包本质；
- 强调“暂时性死区（TDZ）”对变量安全的意义；
- 提前铺垫 `this` 和高阶函数，为后续章节埋线；
- 明确指出箭头函数的优缺点，避免滥用。